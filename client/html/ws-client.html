<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cliente WebSocket</title>
  </head>
  <body>
    <h1>Cliente WebSocket</h1>
    <div>
      <button id="create-game" class="server-operation">Crear un nuevo juego</button>
      <button id="join-game" class="server-operation">Unirse a un juego existente</button>
      <button id="start-game" class="server-operation">¡Iniciar la partida!</button>
      <button id="send-move" class="server-operation">Enviar el movimiento</button>
      <button id="leave-game" class="server-operation">¡Abandonar la partida!</button>
      <button id="close-connection" class="client-operation">Cerrar la conexión con el servidor</button>
    </div>
    <div>
      <input type="text" id="game-id" class="server-operation" placeholder="ID del juego" />
      <input type="text" id="move" class="server-operation" placeholder="Movimiento (p. ej. A1)" />
    </div>
    <div id="messages"></div>

    <script>
      // Constantes que definen el URL del servidor WebSocket
      const WEBSOCKET_SCHEME = 'ws';
      const WEBSOCKET_SERVER = 'batalla-naval.deno.dev';
      const WEBSOCKET_PORT = 80;
      const WEBSOCKET_URL = `${WEBSOCKET_SCHEME}://${WEBSOCKET_SERVER}:${WEBSOCKET_PORT}`;

      // Ahora se crea una instancia de WebSocket. Apenas se crea la instancia se intenta conectar al servidor. Es
      // posible definir un subprotocolo como segundo argumento, pero en este caso no se hace. Si se omite, se usa el
      // subprotocolo por defecto, que es una cadena vacía. El uso de subprotocolos es opcional y depende de la
      // implementación del servidor. Normalmente se usa para indicar al servidor qué tipo de mensajes se van a enviar,
      // pero no es muy común en la práctica, ya que se pueden enviar mensajes de cualquier tipo sin necesidad de
      // especificar un subprotocolo. Sin embargo, a medida que se vayan enviando mensajes más complejos, es posible que
      // se necesite un subprotocolo para indicar al servidor cómo interpretar esos mensajes.
      const socket = new WebSocket(WEBSOCKET_URL);

      /**
       * Se añaden el listener para el evento "open" del WebSocket. Este evento se dispara cuando la conexión
       * se ha establecido con éxito.
       */
      socket.addEventListener('open', () => {
        // Nótese que es posible usar estilos CSS en la consola del navegador:
        console.log(`%cConectado al servidor en ${WEBSOCKET_URL}`,  'color: #99ff00');
      });

      /**
       * Se añade el listener para el evento "message" del WebSocket. Este evento se dispara cuando se recibe
       * un mensaje del servidor.
       *
       * Aunque en este ejemplo no se hace nada con el mensaje recibido (más alla de imprimir la carga útil o "payload"
       * del mensaje en la consola del navegador), en una aplicación real se debería procesar el mensaje de acuerdo
       * a la lógica de negocio de la aplicación. Puede verse un ejemplo de ello en el código asociado al servidor de
       * WebSocket que se encuentra en el archivo `ws-server.ts`.
       */
      socket.addEventListener('message', (event) => {
        // Se convierte el mensaje a un objeto JavaScript, ya que los mensajes se envían como cadenas de texto (string).
        // El mensaje o carga útil (payload) se envió desde el servidor como un objeto JSON serializado como string.
        // Este mensaje está contenido en la propiedad `data` del evento que el navegador pasa como argumento cuando
        // se dispara el evento "message".
        const message = JSON.parse(event.data);

        console.log('%c<- %cMensaje recibido desde el servidor:', 'color: #99ff00', 'color: inherit', message);
      });

      /**
       * Se añade el listener para el evento "close" del WebSocket. Este evento se dispara cuando la conexión
       * se ha cerrado. Esto puede ser debido a que el servidor cerró la conexión, o porque el cliente la cerró
       * explícitamente.
       */
      socket.addEventListener('close', () => {
        console.log('%cSe ha cerrado la conexión con el servidor WebSocket', 'color: #ee0000');

        // La conexión se cerró, por lo tanto, se deshabilitan los botones de operaciones del servidor.
        const buttons = document.getElementsByClassName('server-operation');

        // buttons es un objeto de tipo HTMLCollection, no un array, por lo que no se puede usar forEach directamente.
        // Así que vamos a convertirlo a un arreglo: podemos hacerlo de dos maneras: Array.from(buttons) o [...buttons].
        // Esta última utiliza un operador de propagación ("spread operator") que permite convertir un objeto iterable
        // en una lista o arreglo de argumentos. En este caso, se convierte el objeto HTMLCollection en un arreglo de
        // botones. Esta es la forma más común de convertir un objeto iterable en un arreglo.
        [...buttons].forEach((button) => {
          button.disabled = true;
        });

        // Lo anterior es equivalente a lo siguiente:
        // Array.from(buttons).forEach((button) => {
        //   button.disabled = true;
        // });

        // Idealmente, así como se deshabilitan los botones de operaciones del servidor, en el evento "open" se deberían
        // habilitar nuevamente. Sin embargo, en este ejemplo no se hace eso, ya que la conexión se cierra de manera
        // definitiva y no se vuelve a abrir, porque así lo decidió el programador ;-)

        // Pero, una vez cerrada la conexión, y como este cierre es definitivo, para evitar que el usuario intente
        // realizar operaciones que no se pueden llevar a cabo, se elimina el botón de cerrar la conexión del DOM. Así
        // también mostramos cómo podemos manipular el DOM, en esta ocasión, eliminando un elemento de su árbol.
        const closeButton = document.getElementById('close-connection');
        closeButton.parentNode.removeChild(closeButton);

        // Nótese que, en este caso, se eliminó  el botón obteniendo primero su nodo padre (parentNode) y luego se
        // invocó el método removeChild() de ese nodo padre. Otra forma más directa era simplemente llamar al método
        // remove() del propio elemento, como se muestra a continuación:
        // closeButton.remove();
      });

      /**
       * Se añade el listener para el evento "click" del botón que permite crear un nuevo juego en el servidor. Para
       * ello, se envía un mensaje al servidor con el tipo de operación "create" (ver el código del servidor contenido
       * en ws-server.ts).
      */
      document.getElementById('create-game').addEventListener('click', () => {
        // Nótese que se envía un objeto JSON serializado como string. Este objeto tiene una propiedad `type` que
        // indica el tipo de operación que se desea realizar en el servidor (ver el código fuente del servidor contenido
        // en ws-server.ts).
        // Además de "strings", es posible enviar al servidor otros mensajes codificados en otros formatos, como por
        // ejemplo, mensajes en formato binario (Blobs = Binary Large Objects o ArrayBuffers = datos binarios en pequeña
        // o mediana escala).
        socket.send(JSON.stringify({ type: 'create' }));
      });

      /**
       * Se añade el listener para el evento "click" del botón que permite unirse a un juego existente en el servidor.
       * Para ello, se envía un mensaje al servidor con el tipo de operación "join" (ver el código del servidor contenido
       * en ws-server.ts).
       */
      document.getElementById('join-game').addEventListener('click', () => {
        // Para iniciar una partida, se necesita el ID del juego al que se desea unir. Este ID se obtiene del campo de
        // texto, y se asume que el usuario lo ha ingresado previamente. En una aplicación real, este ID se obtendría de
        // una lista de juegos disponibles, o de una base de datos, o de cualquier otra fuente de datos.
        const gameId = document.getElementById('game-id').value;

        // Ahora se envía un mensaje al servidor con el tipo de operación "join" y el ID del juego al que se desea unir.
        socket.send(JSON.stringify({ type: 'join', gameId }));
      });

      /**
       * Se añade el listener para el evento "click" del botón que permite iniciar la partida en el servidor. Para ello,
       * se envía un mensaje al servidor con el tipo de operación "start" (ver el código del servidor contenido en
       * ws-server.ts).
       */
      document.getElementById('start-game').addEventListener('click', () => {
        // Para iniciar la partida, se necesita el ID del juego al que se desea unir. Este ID se obtiene del campo de
        // texto, y se asume que el usuario lo ha ingresado previamente...
        const gameId = document.getElementById('game-id').value;

        socket.send(JSON.stringify({ type: 'start', gameId }));

        // Nótese que en JavaScript, cuando un objeto tiene una propiedad cuyo valor está contenido en una variable con
        // el mismo nombre, es posible declarar el objeto sin incluir el nombre de la propiedad. Por ejemplo, el objeto
        // que se envía al servidor es equivalente a:
        // socket.send(JSON.stringify({ type: 'start', gameId: gameId }));
      });

      /**
       * Se añade el listener para el evento "click" del botón que permite enviar un movimiento al servidor. Para ello,
       * se envía un mensaje al servidor con el tipo de operación "move" (ver el código del servidor contenido en
       * ws-server.ts).
       */
      document.getElementById('send-move').addEventListener('click', () => {
        // Para enviar un movimiento, se necesita el ID del juego al que se desea unir y el movimiento que se desea
        // realizar. En esta pequeña demostración, estos datos se obtienen de los campos de texto, y se asume que el
        // usuario los ha ingresado previamente. En una aplicación real, estos datos se obtendrían de la interfaz de
        // usuario...
        const gameId = document.getElementById('game-id').value;
        const move = document.getElementById('move').value;

        // Ahora se envía un mensaje al servidor con el tipo de operación "move", el ID del juego y el movimiento que
        // se desea realizar. Nótese que en el caso de gameId y move, los valores están contenidos en variables que
        // tienen el misom nombre que las propiedades del objeto que se envía al servidor, por lo que no hace falta
        // incluir el nombre de dicha propiedad.
        socket.send(JSON.stringify({ type: 'move', gameId, move }));

        // Es decir, el objeto que se envía al servidor es equivalente a:
        // socket.send(JSON.stringify({ type: 'move', gameId: gameId, move: move }));
      });

      /**
       * Se añade el listener para el evento "click" del botón que permite abandonar la partida en el servidor. Para
       * ello, se envía un mensaje al servidor con el tipo de operación "leave" (ver el código del servidor contenido en
       * ws-server.ts).
       */
      document.getElementById('leave-game').addEventListener('click', () => {
        const gameId = document.getElementById('game-id').value;

        socket.send(JSON.stringify({ type: 'leave', gameId }));
      });

      /**
       * Se añade el listener para el evento "click" del botón que permite cerrar la conexión con el servidor de
       * WebSocket. Para ello, se llama al método close() del objeto WebSocket. Este método cierra la conexión con el
       * servidor. Si se desea, es posible pasar un código de estado y una razón al método close(), pero en este caso no
       * se hace.
       */
      document.getElementById('close-connection').addEventListener('click', () => {
        // Se muestra un mensaje de confirmación al usuario antes de cerrar la conexión. Si el usuario confirma,
        // se cierra la conexión con el servidor. De lo contrario, no se hace nada.
        const response = confirm('¿Estás seguro de que deseas cerrar la conexión con el servidor de WebSocket?\n\nSi la cierras, no podrás enviar ni recibir más mensajes y, de acuerdo a esta implementación, tendrás que recargar la página.');

        if (response) {
          socket.close();
        }
      });
    </script>
  </body>
</html>
