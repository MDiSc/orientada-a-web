<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="author" content="Maurizio Di Scipio" />
        <title>Batalla Naval | Primer taller</title>
        <link rel="icon" type="image/jpg" href="..\media\faviconbattleship.webp" />
        <link rel="stylesheet" href="..\styles\help.css">
    </head>
    <body>
        <div id="game-options">
            <button id="create-game" class="server-operation">Crear un nuevo juego</button>
            <button id="join-game" class="server-operation">Unirse a un juego existente</button>
            <button id="start-game" class="server-operation">¡Iniciar la partida!</button>
            <button id="send-move" class="server-operation">Enviar el movimiento</button>
            <button id="leave-game" class="server-operation">¡Abandonar la partida!</button>
            <button id="close-connection" class="client-operation">Cerrar la conexión con el servidor</button>
          </div>
          <div id="game-operations">
            <input type="text" id="game-id" class="server-operation" placeholder="ID del juego" />
            <input type="text" id="move" class="server-operation" placeholder="Movimiento (p. ej. A1)" />
          </div>
          <div id="messages"></div>
        <script>
            // Constantes que definen el URL del servidor WebSocket
            const WEBSOCKET_SCHEME = 'ws';
            const WEBSOCKET_SERVER = 'batalla-naval.deno.dev';
            const WEBSOCKET_PORT = 80;
            const WEBSOCKET_URL = `${WEBSOCKET_SCHEME}://${WEBSOCKET_SERVER}:${WEBSOCKET_PORT}`;
      
            // Ahora se crea una instancia de WebSocket. Apenas se crea la instancia se intenta conectar al servidor. Es
            // posible definir un subprotocolo como segundo argumento, pero en este caso no se hace. Si se omite, se usa el
            // subprotocolo por defecto, que es una cadena vacía. El uso de subprotocolos es opcional y depende de la
            // implementación del servidor. Normalmente se usa para indicar al servidor qué tipo de mensajes se van a enviar,
            // pero no es muy común en la práctica, ya que se pueden enviar mensajes de cualquier tipo sin necesidad de
            // especificar un subprotocolo. Sin embargo, a medida que se vayan enviando mensajes más complejos, es posible que
            // se necesite un subprotocolo para indicar al servidor cómo interpretar esos mensajes.
            const socket = new WebSocket(WEBSOCKET_URL);
      
            /**
             * Se añaden el listener para el evento "open" del WebSocket. Este evento se dispara cuando la conexión
             * se ha establecido con éxito.
             */
            socket.addEventListener('open', () => {
              // Nótese que es posible usar estilos CSS en la consola del navegador:
              console.log(`%cConectado al servidor en ${WEBSOCKET_URL}`,  'color: #99ff00');
            });
      
            /**
             * Se añade el listener para el evento "message" del WebSocket. Este evento se dispara cuando se recibe
             * un mensaje del servidor.
             *
             * Aunque en este ejemplo no se hace nada con el mensaje recibido (más alla de imprimir la carga útil o "payload"
             * del mensaje en la consola del navegador), en una aplicación real se debería procesar el mensaje de acuerdo
             * a la lógica de negocio de la aplicación. Puede verse un ejemplo de ello en el código asociado al servidor de
             * WebSocket que se encuentra en el archivo `ws-server.ts`.
             */
            socket.addEventListener('message', (event) => {
              // Se convierte el mensaje a un objeto JavaScript, ya que los mensajes se envían como cadenas de texto (string).
              // El mensaje o carga útil (payload) se envió desde el servidor como un objeto JSON serializado como string.
              // Este mensaje está contenido en la propiedad `data` del evento que el navegador pasa como argumento cuando
              // se dispara el evento "message".
              const message = JSON.parse(event.data);
      
              console.log('%c<- %cMensaje recibido desde el servidor:', 'color: #99ff00', 'color: inherit', message);
            });
      
            /**
             * Se añade el listener para el evento "close" del WebSocket. Este evento se dispara cuando la conexión
             * se ha cerrado. Esto puede ser debido a que el servidor cerró la conexión, o porque el cliente la cerró
             * explícitamente.
             */
            socket.addEventListener('close', () => {
              console.log('%cSe ha cerrado la conexión con el servidor WebSocket', 'color: #ee0000');
      
              // La conexión se cerró, por lo tanto, se deshabilitan los botones de operaciones del servidor.
              const buttons = document.getElementsByClassName('server-operation');
      
              // buttons es un objeto de tipo HTMLCollection, no un array, por lo que no se puede usar forEach directamente.
              // Así que vamos a convertirlo a un arreglo: podemos hacerlo de dos maneras: Array.from(buttons) o [...buttons].
              // Esta última utiliza un operador de propagación ("spread operator") que permite convertir un objeto iterable
              // en una lista o arreglo de argumentos. En este caso, se convierte el objeto HTMLCollection en un arreglo de
              // botones. Esta es la forma más común de convertir un objeto iterable en un arreglo.
              [...buttons].forEach((button) => {
                button.disabled = true;
              });
      
              // Lo anterior es equivalente a lo siguiente:
              // Array.from(buttons).forEach((button) => {
              //   button.disabled = true;
              // });
      
              // Idealmente, así como se deshabilitan los botones de operaciones del servidor, en el evento "open" se deberían
              // habilitar nuevamente. Sin embargo, en este ejemplo no se hace eso, ya que la conexión se cierra de manera
              // definitiva y no se vuelve a abrir, porque así lo decidió el programador ;-)
      
              // Pero, una vez cerrada la conexión, y como este cierre es definitivo, para evitar que el usuario intente
              // realizar operaciones que no se pueden llevar a cabo, se elimina el botón de cerrar la conexión del DOM. Así
              // también mostramos cómo podemos manipular el DOM, en esta ocasión, eliminando un elemento de su árbol.
              const closeButton = document.getElementById('close-connection');
              closeButton.parentNode.removeChild(closeButton);
      
              // Nótese que, en este caso, se eliminó  el botón obteniendo primero su nodo padre (parentNode) y luego se
              // invocó el método removeChild() de ese nodo padre. Otra forma más directa era simplemente llamar al método
              // remove() del propio elemento, como se muestra a continuación:
              // closeButton.remove();
            });
      
            /**
             * Se añade el listener para el evento "click" del botón que permite crear un nuevo juego en el servidor. Para
             * ello, se envía un mensaje al servidor con el tipo de operación "create" (ver el código del servidor contenido
             * en ws-server.ts).
            */
            document.getElementById('create-game').addEventListener('click', () => {
              // Nótese que se envía un objeto JSON serializado como string. Este objeto tiene una propiedad `type` que
              // indica el tipo de operación que se desea realizar en el servidor (ver el código fuente del servidor contenido
              // en ws-server.ts).
              // Además de "strings", es posible enviar al servidor otros mensajes codificados en otros formatos, como por
              // ejemplo, mensajes en formato binario (Blobs = Binary Large Objects o ArrayBuffers = datos binarios en pequeña
              // o mediana escala).
              socket.send(JSON.stringify({ type: 'create' }));
            });
      
            /**
             * Se añade el listener para el evento "click" del botón que permite unirse a un juego existente en el servidor.
             * Para ello, se envía un mensaje al servidor con el tipo de operación "join" (ver el código del servidor contenido
             * en ws-server.ts).
             */
            document.getElementById('join-game').addEventListener('click', () => {
              // Para iniciar una partida, se necesita el ID del juego al que se desea unir. Este ID se obtiene del campo de
              // texto, y se asume que el usuario lo ha ingresado previamente. En una aplicación real, este ID se obtendría de
              // una lista de juegos disponibles, o de una base de datos, o de cualquier otra fuente de datos.
              const gameId = document.getElementById('game-id').value;
      
              // Ahora se envía un mensaje al servidor con el tipo de operación "join" y el ID del juego al que se desea unir.
              socket.send(JSON.stringify({ type: 'join', gameId }));
            });
      
            /**
             * Se añade el listener para el evento "click" del botón que permite iniciar la partida en el servidor. Para ello,
             * se envía un mensaje al servidor con el tipo de operación "start" (ver el código del servidor contenido en
             * ws-server.ts).
             */
            document.getElementById('start-game').addEventListener('click', () => {
              // Para iniciar la partida, se necesita el ID del juego al que se desea unir. Este ID se obtiene del campo de
              // texto, y se asume que el usuario lo ha ingresado previamente...
              const gameId = document.getElementById('game-id').value;
      
              socket.send(JSON.stringify({ type: 'start', gameId }));
      
              // Nótese que en JavaScript, cuando un objeto tiene una propiedad cuyo valor está contenido en una variable con
              // el mismo nombre, es posible declarar el objeto sin incluir el nombre de la propiedad. Por ejemplo, el objeto
              // que se envía al servidor es equivalente a:
              // socket.send(JSON.stringify({ type: 'start', gameId: gameId }));
            });
      
            /**
             * Se añade el listener para el evento "click" del botón que permite enviar un movimiento al servidor. Para ello,
             * se envía un mensaje al servidor con el tipo de operación "move" (ver el código del servidor contenido en
             * ws-server.ts).
             */
            document.getElementById('send-move').addEventListener('click', () => {
              // Para enviar un movimiento, se necesita el ID del juego al que se desea unir y el movimiento que se desea
              // realizar. En esta pequeña demostración, estos datos se obtienen de los campos de texto, y se asume que el
              // usuario los ha ingresado previamente. En una aplicación real, estos datos se obtendrían de la interfaz de
              // usuario...
              const gameId = document.getElementById('game-id').value;
              const move = document.getElementById('move').value;
      
              // Ahora se envía un mensaje al servidor con el tipo de operación "move", el ID del juego y el movimiento que
              // se desea realizar. Nótese que en el caso de gameId y move, los valores están contenidos en variables que
              // tienen el misom nombre que las propiedades del objeto que se envía al servidor, por lo que no hace falta
              // incluir el nombre de dicha propiedad.
              socket.send(JSON.stringify({ type: 'move', gameId, move }));
      
              // Es decir, el objeto que se envía al servidor es equivalente a:
              // socket.send(JSON.stringify({ type: 'move', gameId: gameId, move: move }));
            });
      
            /**
             * Se añade el listener para el evento "click" del botón que permite abandonar la partida en el servidor. Para
             * ello, se envía un mensaje al servidor con el tipo de operación "leave" (ver el código del servidor contenido en
             * ws-server.ts).
             */
            document.getElementById('leave-game').addEventListener('click', () => {
              const gameId = document.getElementById('game-id').value;
      
              socket.send(JSON.stringify({ type: 'leave', gameId }));
            });
      
            /**
             * Se añade el listener para el evento "click" del botón que permite cerrar la conexión con el servidor de
             * WebSocket. Para ello, se llama al método close() del objeto WebSocket. Este método cierra la conexión con el
             * servidor. Si se desea, es posible pasar un código de estado y una razón al método close(), pero en este caso no
             * se hace.
             */
            document.getElementById('close-connection').addEventListener('click', () => {
              // Se muestra un mensaje de confirmación al usuario antes de cerrar la conexión. Si el usuario confirma,
              // se cierra la conexión con el servidor. De lo contrario, no se hace nada.
              const response = confirm('¿Estás seguro de que deseas cerrar la conexión con el servidor de WebSocket?\n\nSi la cierras, no podrás enviar ni recibir más mensajes y, de acuerdo a esta implementación, tendrás que recargar la página.');
      
              if (response) {
                socket.close();
              }
            });
          </script>
        <audio src="..\media\wavesounds.mp3" autoplay loop></audio>
        <header>
            <h1>BATALLA NAVAL</h1>
            <nav>
                <ul class="menu-hover-fill flex flex-col items-start leading-none text-2xl uppercase space-y-4">
                    <li><a href="#inicio" data-text="inicio">Inicio</a></li>
                    <li><a href="#log-in" data-text="iniciar-sesion">Iniciar sesión</a></li>
                    <li><a href="#registro-usuario" data-text="registrar">Registrar Usuario</a></li>
                    <li><a href="#jugar" data-text="jugar">Jugar</a></li>
                    <li><a href="#instrucciones" data-text="instrucciones">Instrucciones</a></li>
                    <li><a href="#salir" data-text="salir">Salir</a></li>
                </ul>
            </nav>
        </header>
        <main>
            <section id="inicio">
                <h2 id="inicio">Inicio</h2>
                <p>Este es un juego de batalla naval</p>
                <p>Para empezar a jugar, por favor registrate</p>
            </section>
            
            <form id="register" style="display: block">
                <label for="username-log-in">Nombre de usuario:</label>
                <input type="text" id="username" name="username" required />   
                <label for="player">Cantidad de jugadores:</label>
                <label for="player1">CPU</label>
                <input type="radio" id="player1" name="player" value="1" required/>
                <label for="player2">2</label>
                <input type="radio" id="player2" name="player" value="2" required/>
                <label for="player3">3</label>
                <input type="radio" id="player3" name="player" value="3" required/>
                <label for="player4">4</label>
                <input type="radio" id="player4" name="player" value="4" required/>
                <input type="submit" value="Jugar" />           
            </form>
          
            <h2 id="jugar">Jugar</h2>
            <div class="container">
                <div class="deck" id="deck" style="display: none;">
                    <h3>Colocar Barcos</h3>
                    <form id="ship-placement-form">
                        <label for="ship-type">Tipo de Barco:</label>
                        <select id="ship-type" name="ship-type" required>
                            <option value="5">5 casillas</option>
                            <option value="4">4 casillas</option>
                            <option value="3">3 casillas</option>
                            <option value="3">3 casillas</option>
                            <option value="2">2 casillas</option>
                        </select>
                        <label for="start-coordinates">Coordenadas Iniciales:</label>
                        <input type="text" id="start-coordinates" name="start-coordinates" placeholder="Ej: 01 (v/>)" required />
                        <label for="direction">Dirección:</label>
                        <select id="direction" name="direction" required>
                            <option value="0">Horizontal</option>
                            <option value="1">Vertical</option>
                        </select>
                        <input type="submit" id="add-button" value="Colocar" />
                        <button id="confirm-button" style="display: none;">Confirmar</button>
                    </form>
                </div>
                <div class="tables" id="tables">

                </div>
                <div id="placed-ships" style="display: none;">
                    <h3>Barcos Colocados</h3>
                    <ul id="placed-ships-list"></ul>
            </div>
        </main>
        <aside id="instrucciones">
            <h2>Instrucciones</h2>
            <div id="container-for-instructions">
                <div class="box">
                    <h3>1. Objetivo del Juego</h3>
                    <p>Hundir toda la flota enemiga antes que tu oponente hunda la tuya.</p>
                </div>
                <div class="box">
                    <h3>2. Componentes del Juego</h3>
                    <p>Tablero de juego para cada jugador (10x10 cuadrículas)...</p>
                    <ul class="lista-barcos">
                        <li>1 portaaviones (5 casillas)</li>
                        <li>1 acorazado (4 casillas)</li>
                        <li>1 crucero (3 casillas)</li>
                        <li>1 submarino (3 casillas)</li>
                        <li>1 destructor (2 casillas)</li>
                    </ul>
                </div>
                <div class="box">
                    <h3>3. Preparación</h3>
                    <p>Cada jugador coloca sus barcos en el tablero de manera oculta al oponente...</p>
                </div>
                <div class="box">
                    <h3>4. Turnos</h3>
                    <p>Los jugadores se turnan para "disparar" a las casillas del oponente...</p>
                </div>
                <div class="box">
                    <h3>5. Impactos</h3>
                    <p>Si un jugador acierta un disparo en una casilla que contiene parte de un barco enemigo...</p>
                </div>
                <div class="box">
                    <h3>6. Hundimiento</h3>
                    <p>Cuando todas las casillas de un barco han sido impactadas, el barco se considera "hundido"...</p>
                </div>
                <div class="box">
                    <h3>7. Victoria</h3>
                    <p>El primer jugador en hundir toda la flota enemiga gana la partida.</p>
                </div>
                <div class="box">
                    <h3>8. Duración del Turno</h3>
                    <p>Se debe establecer un límite de tiempo para cada turno de 60 segundos</p>
                </div>
            </div>
        </aside>
              
        <footer>
            <h2 id="salir">Salir</h2>
            <p>Gracias por jugar</p>
            <a href="https://www.youtube.com/watch?v=nCtn6igpgP4">Pulse aqui para salir.</a>
        </footer>
    </body>
    <script src="..\scripts\help.js"></script>
</html>
